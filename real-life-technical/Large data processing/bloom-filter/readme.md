HashMap 是我们使用最多的数据结构，并且我们知道了在海量数据处理中，内存资源非常珍贵。

布隆过滤器（Bloom Filter，简写为 BF）

- 对普通的哈希表做了进一步的改进，是一种更省空间的哈希表。
- 当碰到内存不够的问题时，BF 就是一个很好的选择。

BF 一般有两个功能：

检测一个元素在不在一个集合中
统计一个元素的出现次数

在 Java 里面，这不就是 HashSet 和 HashMap 的作用么？实际上 BF 能做的事情就是哈希表能做的事情，但是 BF 相比哈希表，耗费更少的存储空间。既然节省了空间，同样也有一个副作用：存在 False Positive（正误识）。

现在你可能会有疑问，BF 会产生 False Positive 的话，是否会产生 False Negative 呢？答案是不会。也就是说，BF 说这个元素不在集合里，那就一定不在集合里。

现在你已经对 BloomFilter 有了大概的印象，一个更完整的 BloomFilter 会包含以下两个部分：

k 个完全独立的哈希函数
一个很大的数组
然后根据处理的问题的不同，BloomFilter 可以分为：
标准型布隆过滤器（Standard Bloom Filter，简写为 SBF，对应到 Java 里的 HashSet）
计数型布隆过滤器（Counting Bloom Filter，简写为 CBF，对应到 Java 里的 HashMap）
对于 SBF，其包含的大数组的类型为 Boolean 类型。对于 CBF，其包含的大数组的类型为整数类型。

接下来我们来讨论 BloomFilter 的第一个部分：k 个不同的哈希函数
一般来说，可以使用几个不同的算法，来获得不同的哈希函数。一个比较通用的哈希函数的写法是这样：

def hashfunc(string, hashsize):
code = 0
for c in string:
code = code \* 31 + ord(c)
code = code % hashsize

    return code

在数据结构中，哈希函数是用来将一个字符串（或任何其他类型）转化为小于哈希表大小且大于等于零的整数。一个好的哈希函数可以尽可能少地产生冲突。一种广泛使用的哈希函数算法是使用数值 33，假设任何字符串都是基于 33 的一个大整数，比如：

hashcode("abcd") = (ascii(a) _ 333 + ascii(b) _ 332 + ascii(c) \*33 + ascii(d)) % HASH_SIZE

如果需要设计 k 个独立的哈希函数，只需要对上面的代码块儿，简单地修改上面的函数中的 Magic Number 31 即可，比如换成 37，41 这样。

其实上面的这个算法，相当于把一个字符串当做了 31 进制，然后转换为整数。一遍转换的过程中一遍对 hashsize 取模，避免溢出。

而 31 也不是唯一的选择，但是有一些基本的法则我们需要遵守：

不能太小。太小的话，容易出现 hashfunc 算出来的值在字符串比较短的时候出现扎堆的情况。增加了哈希碰撞的几率。
不能太大。太大的话，影响了计算效率。
尽量不要是合数。合数也可能会增加哈希碰撞的几率。

了解了 Hash Function 的工作之后，我们会分别介绍标准型布隆过滤器（Standard Bloom Filter）和计数型布隆过滤器（Counting Bloom Filter）。

标准布隆过滤器的作用相当于一个 HashSet，即提供了这样一个数据结构，他支持如下操作：

在集合中加入一个元素
判断一个元素是否在集合中（允许 False Positive）。

其实现通常包含以下几个部分：

初始化：开一个足够大的 boolean 数组，初始值都是 false。
插入一个元素：通过 k 个哈希函数，计算出元素的 k 个哈希值，对 boolean 数组的长度取模之后，标记对应的 k 个位置上的值为 true。
查询一个元素：通过同样的 k 哈希函数，在 boolean 数组中取出对应的 k 个位置上的值。如果都是 true，则表示该元素可能存在，如果有一个 false，则表示一定不存在。

在具体实现的时候，为了更好地节省空间，可以用位运算的方式来代替 boolean 数组。Java 中可以直接用 BitSet 这个结构。

前面我们讲了标准的 BloomFilter，如果我们对 SBF 稍作改动，把存储所用的 boolean 数组改为 int 数组，就成为了可以计数的 BloomFilter—— Counting Bloom Filter（简写为 CBF）。这个数据结构类似 Java 中的 HashMap，但只能用作计数。提供如下的几种操作：

O(1)时间内，在集合中加入一个元素
O(1)时间内，统计某个元素在该集合中出现的次数 - 但是可能会比实际出现次数要大一些

具体的实现步骤主要包含一下基本部分：

初始化：开一个足够大的 int 数组，初始值都是 0。
插入一个元素：通过 k 个哈希函数，计算出元素的 k 个哈希值，对 int 数组的长度取模之后，将对应的 k 个位置上的值都加一。
查询一个元素的出现次数：通过同样的 k 哈希函数，在 int 数组中取出对应的 k 个位置上的值。并取其中的最小值来作为该元素的出现次数预估。
